[WIP - Random notes] 

Here is a final example that shows the connect function :

```
import {connect} from 'react-redux';
import Template from '../components/Template.js';
import {actionCreator1, actionCreator2} from '../actions/main.js';

const mapStateToProps = ({ reducer1, reducer2}) => ({reducer1, reducer2 });

const bindActionsToDispatch = dispatch => ({
    actionCreator1 : () => {dispatch(actionCreator1())},
    actionCreator2 : (e) => {dispatch(actionCreator2(e))}
});

const mergeProps = (state, actions, {notebook, note}) => ({
    ...state,
    ...actions,
    onLoad: notebook && note
      ? () => {
        return (
          actions.initActiveNotebookAndNote({notebook, note})
        )
      }
      : null
});

connect(mapStateToProps, mapDispatchToProps, mergeProps, { withRef: true })(Template);
```

--------

connect(mapStateToProps, mapDispatchToProps, mergeProps, options)(component);

	.	mapStateToProps
	.	mapDispatchToProps
	.	mergeProps — optional
	.	options — optional

I think it would be helpful to mention that the container component is generated by the react-redux library connect() method. The benefit of using connect(state, dispatch) is that it takes care of subscribe (responding to state changes) and dispatch for you without having to hook into the React component lifecycle methods (componentDidMount and componentWillUnmount)


Enter Redux’s Container
------------------------

There needs to be glue that connects the Redux data flow with the React components. The container is meant to be the file that holds all the data and functions required to connect store state and action creators actions to React component props. It is in this file where your action creators are imported, the Redux ‘connect’ function is imported, the parent React component is imported, and any other methods/data are imported (i.e routing and initial server loading).

```
import {connect} from 'react-redux';
import Template from '../components/Template.js'
import {increment, decrement} from '../actions/sidebar.js';
import {isBrowser} from '../env.js';
```

Now the connect function. The documentation for connect within Redux is difficult to understand, which creates a sense of mystery. Simply think of this as a component that takes props as parameters, which in return supplies actions and state to the provided React component via props… Confused yet? Well let’s break this down some more.

connect() is a function provided by react-redux. If a component wants to get state updates, it wraps itself using connect(). Then the connect function will set up all the wiring for it to the redux store.

The following shows the connect function breakdown:

```
connect(mapStateToProps, mapDispatchToProps, mergeProps, options)(component);
```

Connect returns a function that accepts a react component. It has 4 arguments.

* mapStateToProps - function, mandatory
* mapDispatchToProps - function or object, mandotory
* mergeProps — function, optional
* options — object, optional

When applied to a component, it returns a component connected to the store that renders the specified component.


## mapStateToProps

The function `mapStateToProps` connects state from the store to corresponding props. This make it possible to access your reducer state objects from within your React components.
As connect subscribes to the store automatically, a new render of the connected component triggered anytime a change of state triggers a change of value for any of the properties passed to the component.

`mapStateToProps` returns an object, where keys are the prop names passed to the connected component and the value a reducer function.

```
const mapStateToProps = ({ reducer1, reducer2}) => ({reducer1, reducer2 });
```

## mapDispatchToProps

`mapDispatchToProps` can ether be a function or an object.

As the only way to change the application state is by dispatching an action, this allows to create named function for handling dispatch calls (i.e.: action creator).

When the name funtion is called with arguments, the associated named function will be called with the current getState() result and the given action synchronously. Its return value will be considered the next state.

```
import {actionCreator1, actionCreator2} from '../actions/main.js';

const bindActionsToDispatch = (dispatch) => ({
    actionCreator1 : () => {dispatch(actionCreator1())},
    actionCreator2 : (e) => {dispatch(actionCreator2(e))}
});
```

### bindActionCreators

`mapDispatchToProps` is not the only way of bind dispatch and action creators, there is another way called `bindActionCreators`.

```
import { bindActionCreators } from 'redux';
import * as TodoActionCreators from './TodoActionCreators';

let boundActionCreators = bindActionCreators(TodoActionCreators, dispatch)
```

The only use case for bindActionCreators is when you want to pass some action creators down to a component that isn't aware of Redux, and you don't want to pass dispatch or the Redux store to it.

## mergeProps

`mergeProps` is an optional parameter and is a function. The documentation on this particular function does not explain much as to it’s purpose and use cases. Hence adding to the mystery of the connect function.

If it is used, this function is passed the result of `mapStateToProps`(), `mapDispatchToProps`(), and the parent props. With this data available, it is easy to use props inherited from connect’s parent and combine them with an action creator. For example, if you are working with React Router, the variables assigned in the route path are passed as props to the connect function, if it is the connect function’s parent. You could then use those props and pass it along to your action creators to update your store with the needed URL parameters.

```
const mergeProps = (state, actions, {notebook, note}) => ({
    ...state,
    ...actions,
    onLoad: notebook && note
      ? () => {
        return Promise.all([
          actions.initActiveNotebookAndNote({notebook, note})
        ])
      }
      : actions.onLoad
})
```

The above code is receiving state from mapStateToProps, actions from mapDispatchToProps, and is creating a new prop called ‘onLoad’. This prop ‘onLoad’ is combining or ‘merging’ (as it’s name states) props from it’s parent component (React Router) and an action creator together. That action creator can be used to update data within a Reducer:

```
export const initActiveNotebookAndNote = ({notebook, note}) => ({
 type: SET_CURRENT_NOTE,
 notebook,
 note
});
```

## options

The options parameter is an object. It is used to customize the behavior of the connect function. The acceptable ‘options’ are the following:

* pure- Boolean, if true connect() will avoid re-rendering (will not update)
* areStatesEqual- Compares new store state vs. old*
* areOwnPropsEqual- Compares new props vs. old*
* areStatePropsEqual- Compares new mapStateToProps vs. old*
* areMergedPropsEqual- Compares new mergeProps vs. old*

(*Only when pure functions)

These options are not commonly used and are best explained by Redux:

You may wish to override `areStatesEqual` if your `mapStateToProps` function is computationally expensive and is also only concerned with a small slice of your state. For example: areStatesEqual: (prev, next) => prev.entities.todos === next.entities.todos; this would effectively ignore state changes for everything but that slice of state.

You may wish to override `areStatesEqual` to always return false (areStatesEqual: () => false) if you have impure reducers that mutate your store state. (This would likely impact the other equality checks is well, depending on your mapStateToProps function.)

You may wish to override `areOwnPropsEqual` as a way to whitelist incoming props. You'd also have to implement mapStateToProps, mapDispatchToProps and mergeProps to also whitelist props. (It may be simpler to achieve this other ways, for example by using recompose's mapProps.)

You may wish to override `areStatePropsEqual` to use strictEqual if your mapStateToProps uses a memoized selector that will only return a new object if a relevant prop has changed. This would be a very slight performance improvement, since would avoid extra equality checks on individual props each time mapStateToProps is called.

You may wish to override `areMergedPropsEqual` to implement a deepEqual if your selectors produce complex props. ex: nested objects, new arrays, etc. (The deep equal check should be faster than just re-rendering.)


###

To use connect(), you need to define a special function called `mapStateToProps` that tells how to transform the current Redux store state into the props you want to pass to a presentational component you are wrapping. For example, `VisibleTodoList` needs to calculate todos to pass to the `TodoList`, so we define a function that filters the `state.todos` according to the `state.visibilityFilter`, and use it in its mapStateToProps:

```
const getVisibleTodos = (todos, filter) => {
  switch (filter) {
    case 'SHOW_ALL':
      return todos
    case 'SHOW_COMPLETED':
      return todos.filter(t => t.completed)
    case 'SHOW_ACTIVE':
      return todos.filter(t => !t.completed)
  }
}

const mapStateToProps = (state) => {
  return {
    todos: getVisibleTodos(state.todos, state.visibilityFilter)
  }
}
```

In addition to reading the state, container components can dispatch actions. In a similar fashion, you can define a function called `mapDispatchToProps()` that receives the dispatch() method and returns callback props that you want to inject into the presentational component. For example, we want the VisibleTodoList to inject a prop called `onTodoClick` into the `TodoList` component, and we want onTodoClick to dispatch a `TOGGLE_TODO` action:

```
const mapDispatchToProps = (dispatch) => {
  return {
    onTodoClick: (id) => {
      dispatch(toggleTodo(id))
    }
  }
}
```

Finally, we create the VisibleTodoList by calling connect() and passing these two functions:

```
import { connect } from 'react-redux'

const VisibleTodoList = connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoList)

export default VisibleTodoList
```

These are the basics of the React Redux API, but there are a few shortcuts and power options so we encourage you to check out its documentation in detail. In case you are worried about mapStateToProps creating new objects too often, you might want to learn about computing derived data with reselect.


```
containers/FilterLink.js

import { connect } from 'react-redux'
import { setVisibilityFilter } from '../actions'
import Link from '../components/Link'

const mapStateToProps = (state, ownProps) => {
  return {
    active: ownProps.filter === state.visibilityFilter
  }
}

const mapDispatchToProps = (dispatch, ownProps) => {
  return {
    onClick: () => {
      dispatch(setVisibilityFilter(ownProps.filter))
    }
  }
}

const FilterLink = connect(
  mapStateToProps,
  mapDispatchToProps
)(Link)

export default FilterLink
```

## Async Actions

You can return things from thunks. Thunks are basically async action creators. Returning promises from thunks is useful, because then you can chain together async functions.

Of course, after using many thunks and promises, and having errors constantly being swallowed, I really wish I had tried out something like redux-saga instead.

## Async Actions

When you call an asynchronous API, there are two crucial moments in time: the moment you start the call, and the moment when you receive an answer (or a timeout).

Each of these two moments usually require a change in the application state; to do that, you need to dispatch normal actions that will be processed by reducers synchronously. Usually, for any API request you'll want to dispatch at least three different kinds of actions:

* An action informing the reducers that the request began. The reducers may handle this action by toggling an isFetching flag in the state. This way the UI knows it's time to show a spinner.

* An action informing the reducers that the request finished successfully. The reducers may handle this action by merging the new data into the state they manage and resetting isFetching. The UI would hide the spinner, and display the fetched data.

* An action informing the reducers that the request failed. The reducers may handle this action by resetting isFetching. Additionally, some reducers may want to store the error message so the UI can display it.


### Designing the State Shape

Just like in the basic tutorial, you'll need to design the shape of your application's state before rushing into the implementation. With asynchronous code, there is more state to take care of, so we need to think it through.

This part is often confusing to beginners, because it is not immediately clear what information describes the state of an asynchronous application, and how to organize it in a single tree.

We'll start with the most common use case: lists. Web applications often show lists of things. For example, a list of posts, or a list of friends. You'll need to figure out what sorts of lists your app can show. You want to store them separately in the state, because this way you can cache them and only fetch again if necessary.

Here's what the state shape for our “Reddit headlines” app might look like:

```
{
  selectedSubreddit: 'frontend',
  postsBySubreddit: {
    frontend: {
      isFetching: true,
      didInvalidate: false,
      items: []
    },
    reactjs: {
      isFetching: false,
      didInvalidate: false,
      lastUpdated: 1439478405547,
      items: [
        {
          id: 42,
          title: 'Confusion about Flux and Relay'
        },
        {
          id: 500,
          title: 'Creating a Simple Application Using React JS and Flux Architecture'
        }
      ]
    }
  }
}
```

There are a few important bits here:

We store each subreddit's information separately so we can cache every subreddit. When the user switches between them the second time, the update will be instant, and we won't need to refetch unless we want to. Don't worry about all these items being in memory: unless you're dealing with tens of thousands of items, and your user rarely closes the tab, you won't need any sort of cleanup.

For every list of items, you'll want to store isFetching to show a spinner, didInvalidate so you can later toggle it when the data is stale, lastUpdated so you know when it was fetched the last time, and the items themselves. In a real app, you'll also want to store pagination state like fetchedPageCount and nextPageUrl.

Note on Nested Entities

In this example, we store the received items together with the pagination information. However, this approach won't work well if you have nested entities referencing each other, or if you let the user edit items. Imagine the user wants to edit a fetched post, but this post is duplicated in several places in the state tree. This would be really painful to implement.

If you have nested entities, or if you let users edit received entities, you should keep them separately in the state as if it was a database. In pagination information, you would only refer to them by their IDs. This lets you always keep them up to date. The real world example shows this approach, together with normalizr to normalize the nested API responses. With this approach, your state might look like this:

```
{
  selectedSubreddit: 'frontend',
  entities: {
    users: {
      2: {
        id: 2,
        name: 'Andrew'
      }
    },
    posts: {
      42: {
        id: 42,
        title: 'Confusion about Flux and Relay',
        author: 2
      },
      100: {
        id: 100,
        title: 'Creating a Simple Application Using React JS and Flux Architecture',
        author: 2
      }
    }
  },
  postsBySubreddit: {
    frontend: {
      isFetching: true,
      didInvalidate: false,
      items: []
    },
    reactjs: {
      isFetching: false,
      didInvalidate: false,
      lastUpdated: 1439478405547,
      items: [ 42, 100 ]
    }
  }
}
```

In this guide, we won't normalize entities, but it's something you should consider for a more dynamic application.

### Handling Actions

Before going into the details of dispatching actions together with network requests, we will write the reducers for the actions we defined above.

### Note on Reducer Composition

Here, we assume that you understand reducer composition with combineReducers(), as described in the Splitting Reducers section on the basics guide. If you don't, please read it first.

reducers.js

```
import { combineReducers } from 'redux'
import {
  SELECT_SUBREDDIT, INVALIDATE_SUBREDDIT,
  REQUEST_POSTS, RECEIVE_POSTS
} from '../actions'

function selectedSubreddit(state = 'reactjs', action) {
  switch (action.type) {
    case SELECT_SUBREDDIT:
      return action.subreddit
    default:
      return state
  }
}

function posts(state = {
  isFetching: false,
  didInvalidate: false,
  items: []
}, action) {
  switch (action.type) {
    case INVALIDATE_SUBREDDIT:
      return Object.assign({}, state, {
        didInvalidate: true
      })
    case REQUEST_POSTS:
      return Object.assign({}, state, {
        isFetching: true,
        didInvalidate: false
      })
    case RECEIVE_POSTS:
      return Object.assign({}, state, {
        isFetching: false,
        didInvalidate: false,
        items: action.posts,
        lastUpdated: action.receivedAt
      })
    default:
      return state
  }
}

function postsBySubreddit(state = {}, action) {
  switch (action.type) {
    case INVALIDATE_SUBREDDIT:
    case RECEIVE_POSTS:
    case REQUEST_POSTS:
      return Object.assign({}, state, {
        [action.subreddit]: posts(state[action.subreddit], action)
      })
    default:
      return state
  }
}

const rootReducer = combineReducers({
  postsBySubreddit,
  selectedSubreddit
})

export default rootReducer
```

In this code, there are two interesting parts:

We use ES6 computed property syntax so we can update state[action.subreddit] with Object.assign() in a terse way. This:

```
return Object.assign({}, state, {
  [action.subreddit]: posts(state[action.subreddit], action)
})
```

is equivalent to this:

```
let nextState = {}
nextState[action.subreddit] = posts(state[action.subreddit], action)
return Object.assign({}, state, nextState)
```

We extracted posts(state, action) that manages the state of a specific post list. This is just reducer composition! It is our choice how to split the reducer into smaller reducers, and in this case, we're delegating updating items inside an object to a posts reducer. The real world example goes even further, showing how to create a reducer factory for parameterized pagination reducers.
Remember that reducers are just functions, so you can use functional composition and higher-order functions as much as you feel comfortable.

# Async Flow

Perhaps the trickiest part is making async requests and handling responses. While there are many examples, there is no well established pattern for making async requests and handling responses in Redux apps(just yet).

Without middleware, Redux store only supports synchronous data flow. This is what you get by default with createStore().

You may enhance createStore() with applyMiddleware(). It is not required, but it lets you express asynchronous actions in a convenient way.

Asynchronous middleware like redux-thunk or redux-promise wraps the store's dispatch() method and allows you to dispatch something other than actions, for example, functions or Promises. Any middleware you use can then interpret anything you dispatch, and in turn, can pass actions to the next middleware in the chain. For example, a Promise middleware can intercept Promises and dispatch a pair of begin/end actions asynchronously in response to each Promise.

When the last middleware in the chain dispatches an action, it has to be a plain object. This is when the synchronous Redux data flow takes place.

Check out the full source code for the async example.

### Async Action Creators

Finally, how do we use the synchronous action creators we defined earlier together with network requests? The standard way to do it with Redux is to use the Redux Thunk middleware. It comes in a separate package called redux-thunk. We'll explain how middleware works in general later; for now, there is just one important thing you need to know: by using this specific middleware, an action creator can return a function instead of an action object. This way, the action creator becomes a thunk.

When an action creator returns a function, that function will get executed by the Redux Thunk middleware. This function doesn't need to be pure; it is thus allowed to have side effects, including executing asynchronous API calls. The function can also dispatch actions—like those synchronous actions we defined earlier.

We can still define these special thunk action creators inside our actions.js file:

actions.js

```
import fetch from 'isomorphic-fetch'

export const REQUEST_POSTS = 'REQUEST_POSTS'
function requestPosts(subreddit) {
  return {
    type: REQUEST_POSTS,
    subreddit
  }
}

export const RECEIVE_POSTS = 'RECEIVE_POSTS'
function receivePosts(subreddit, json) {
  return {
    type: RECEIVE_POSTS,
    subreddit,
    posts: json.data.children.map(child => child.data),
    receivedAt: Date.now()
  }
}

// Meet our first thunk action creator!
// Though its insides are different, you would use it just like any other action creator:
// store.dispatch(fetchPosts('reactjs'))

export function fetchPosts(subreddit) {

  // Thunk middleware knows how to handle functions.
  // It passes the dispatch method as an argument to the function,
  // thus making it able to dispatch actions itself.

  return function (dispatch) {

    // First dispatch: the app state is updated to inform
    // that the API call is starting.

    dispatch(requestPosts(subreddit))

    // The function called by the thunk middleware can return a value,
    // that is passed on as the return value of the dispatch method.

    // In this case, we return a promise to wait for.
    // This is not required by thunk middleware, but it is convenient for us.

    return fetch(`https://www.reddit.com/r/${subreddit}.json`)
      .then(response => response.json())
      .then(json =>

        // We can dispatch many times!
        // Here, we update the app state with the results of the API call.

        dispatch(receivePosts(subreddit, json))
      )

      // In a real world app, you also want to
      // catch any error in the network call.
  }
}
```

### Note on fetch

We use fetch API in the examples. It is a new API for making network requests that replaces XMLHttpRequest for most common needs. Because most browsers don't yet support it natively, we suggest that you use isomorphic-fetch library:

```
// Do this in every file where you use `fetch`
import fetch from 'isomorphic-fetch'
```

Internally, it uses whatwg-fetch polyfill on the client, and node-fetch on the server, so you won't need to change API calls if you change your app to be universal.

Be aware that any fetch polyfill assumes a Promise polyfill is already present. The easiest way to ensure you have a Promise polyfill is to enable Babel's ES6 polyfill in your entry point before any other code runs:

// Do this once before any other code in your app
import 'babel-polyfill'
How do we include the Redux Thunk middleware in the dispatch mechanism? We use the applyMiddleware() store enhancer from Redux, as shown below:

index.js
```
import thunkMiddleware from 'redux-thunk'
import createLogger from 'redux-logger'
import { createStore, applyMiddleware } from 'redux'
import { selectSubreddit, fetchPosts } from './actions'
import rootReducer from './reducers'

const loggerMiddleware = createLogger()

const store = createStore(
  rootReducer,
  applyMiddleware(
    thunkMiddleware, // lets us dispatch() functions
    loggerMiddleware // neat middleware that logs actions
  )
)

store.dispatch(selectSubreddit('reactjs'))
store.dispatch(fetchPosts('reactjs')).then(() =>
  console.log(store.getState())
)
The nice thing about thunks is that they can dispatch results of each other:
```

actions.js

```
import fetch from 'isomorphic-fetch'

export const REQUEST_POSTS = 'REQUEST_POSTS'
function requestPosts(subreddit) {
  return {
    type: REQUEST_POSTS,
    subreddit
  }
}

export const RECEIVE_POSTS = 'RECEIVE_POSTS'
function receivePosts(subreddit, json) {
  return {
    type: RECEIVE_POSTS,
    subreddit,
    posts: json.data.children.map(child => child.data),
    receivedAt: Date.now()
  }
}

function fetchPosts(subreddit) {
  return dispatch => {
    dispatch(requestPosts(subreddit))
    return fetch(`https://www.reddit.com/r/${subreddit}.json`)
      .then(response => response.json())
      .then(json => dispatch(receivePosts(subreddit, json)))
  }
}

function shouldFetchPosts(state, subreddit) {
  const posts = state.postsBySubreddit[subreddit]
  if (!posts) {
    return true
  } else if (posts.isFetching) {
    return false
  } else {
    return posts.didInvalidate
  }
}

export function fetchPostsIfNeeded(subreddit) {

  // Note that the function also receives getState()
  // which lets you choose what to dispatch next.

  // This is useful for avoiding a network request if
  // a cached value is already available.

  return (dispatch, getState) => {
    if (shouldFetchPosts(getState(), subreddit)) {
      // Dispatch a thunk from thunk!
      return dispatch(fetchPosts(subreddit))
    } else {
      // Let the calling code know there's nothing to wait for.
      return Promise.resolve()
    }
  }
}
```


This lets us write more sophisticated async control flow gradually, while the consuming code can stay pretty much the same:

index.js

```
store.dispatch(fetchPostsIfNeeded('reactjs')).then(() =>
  console.log(store.getState())
)
```

### Note about Server Rendering

Async action creators are especially convenient for server rendering. You can create a store, dispatch a single async action creator that dispatches other async action creators to fetch data for a whole section of your app, and only render after the Promise it returns, completes. Then your store will already be hydrated with the state you need before rendering.

Thunk middleware isn't the only way to orchestrate asynchronous actions in Redux:

* You can use redux-promise or redux-promise-middleware to dispatch Promises instead of functions.
* You can use redux-observable to dispatch Observables.
* You can use the redux-saga middleware to build more complex asynchronous actions.
* You can use the redux-pack middleware to dispatch promise-based asynchronous actions.
* You can even write a custom middleware to describe calls to your API, like the real world example does.

It is up to you to try a few options, choose a convention you like, and follow it, whether with, or without the middleware.


---

https://medium.com/@rajaraodv/a-guide-for-building-a-react-redux-crud-app-7fe0b8943d0f

PATTERN: Dealing With Async Actions

If component is loading an object(e.g. list of Posts) via AJAX call to the server, that object’s state should keep track of all the potential states. Initial state for such objects should look like: {objName: {obj:null, loading: false, error:null}}.
Further, such components should dispatch up to 4 actions such as “FETCH_OBJ”(for loading), “FETCH_OBJ_SUCCESS”, “FETCH_OBJ_FAILURE” and “OBJ_RESET”(to cleanup dirty previous state).
For example, if we are loading list of posts..
Note: You can click on the pictures to zoom and read

Initial State: Initial state should look like,
{postsList:{posts:[], loading:false, error:null}}
Actions:
FETCH_OBJ — Dispatch this to make the server request and also let other components know we are loading. This helps current/other components show “loading” or hide or do something.
dispatch({“type”: “FETCH_POSTS”, loading: true})
Once Redux gets this and passes it through reducers, the new state will look something like:
{postList: {posts:null, error: null, loading: true}}
2. FETCH_OBJ_SUCCESS: Dispatch this when you get successful response. This is to show the actual data and also to cancel “loading”
dispatch({"type": "FETCH_POSTS_SUCCESS", "posts":[post1, post2])
Once Redux gets this and passes it through reducers, the new state will look something like:
{postsList:{posts:[post1, post2], error:null, loading: false}}
3.FETCH_OBJ_FAILURE: Dispatch this when you get a failed response. This is to show some error message and also to cancel “loading”.
dispatch({"type": "FETCH_POSTS_FAILURE", "error": "Error message"})
Once Redux gets this and passes it through reducers, the new state will look something like:
{postList:{posts:null, error:{msg: "Error msg"}, loading: false}}
4.RESET_OBJ: Dispatch this to reset the component’s state after success/failure. This is optional but can be useful when you want to reuse a “dirty” component from previous AJAX request.
dispatch({"type": "RESET_POST", loading: false, "post": null, "error": "Error message"})
Once Redux gets this and passes it through reducers, the new state will look something like:
{postList:{post:null, error:null, loading: false}}
STEP 3 — List State and Actions For Each Component (AND For Each Phase)
Take a look at each component one by one and each phase and list of state and actions.
We have 4 components: 1. PostsList, 2. PostDetails 3. PostForm and 4. Header components.
3.1 PostList Component — List State And Actions

States:
List out various data that may change the display of the component in all phases of the component.
Shows list of Posts. Let’s call the state as “posts” (an array).
Shows “Loading..”, if it’s in the processing fetching the posts. Let’s call this state “loading”(boolean)
Shows “Error” if there is an error. Let’s call this state as “error”(null or error info).
Since all the above are related to PostList, let’s put them in a single state object called postList.
{ postsList: {posts: [], error:null, loading: false} //initial state
Actions:
This component makes a “AJAX” call to load posts, so we’ll use the above mentioned pattern and create 4 actions.
1.Asks server for list of posts. Let’s call this action as: “FETCH_POSTS”.
export function fetchPosts() {
 const request = axios.get(`${ROOT_URL}/posts`);
return {
 type: FETCH_POSTS,
 payload: request
 };
}
2.Tells every component that it received posts (success case). Let’s call this “FETCH_POSTS_SUCCESS”
export function fetchPostsSuccess(posts) {
 return {
 type: FETCH_POSTS_SUCCESS,
 payload: posts
 };
}
3.Tells every component that there was an error(failure case). Let’s call this “FETCH_POSTS_FAILURE”
export function fetchPostsFailure(error) {
 return {
 type: FETCH_POSTS_FAILURE,
 payload: error
 };
}
4. Resetting data is not required because this is the 1st page (you’ll see how this is useful in other 2 pages)
3.2 PostDetails Component — List State And Actions
Note: You can click on the pictures to zoom and read

3.3 PostForm Component — State And Actions

3.4 Header Component — List State And Actions

STEP 4 — Create Action Creators For Each Action
We have a total of 12 actions(4 actions x 3 pages), create action creators for each one. Please see the source code here.
//Example Action creators...
export function fetchPosts() {
 const request = axios.get(`${ROOT_URL}/posts`);
return {
 type: FETCH_POSTS,
 payload: request
 };
}
export function fetchPostsSuccess(posts) {
 return {
 type: FETCH_POSTS_SUCCESS,
 payload: posts
 };
}
...
Redux Term: “Reducers”
Reducers are functions that take “state” from Redux and “action” JSON object and returns a new “state” to be stored back in Redux.

1. Reducer functions are called by the “Container” containers when there is a user or server action.
2. If the reducer changes the state, Redux passes the new state to each component and React re-renders each component
The below function takes the current "postsList" inside "...state" and merges new "postList" and creates a **new** state(json), if the action is "FECTH_POSTS_SUCCESS"
case FETCH_POSTS_SUCCESS:
 return { …state, postsList: {posts: action.payload, error:null,
                              loading: false}
        };
STEP 5 — Write Reducers For Each Action
We have 12 actions, we need to write reducers for each one of them.
Please look at the source code for details here.
Redux Term: “Presentational” and “Container” Components
Keeping React and Redux logic inside each component can make it messy, so Redux recommends creating a dummy presentation only component called “Presentational” component and a parent wrapper component called “Container” component that deals w/ Redux, dispatch “Actions” and more.

The parent Container then passes the data to the presentational component, handle events, deal with React on behalf of Presentational component.

Legend: Yellow dotted lines = “Presentational” components. Black dotted lines = “Container” components.
STEP 6 — Implement Every Presentational Component
We have 4 components: PostsList, PostDetails, PostForm and Header. Let’s create presentational components for each one.
6.1 Implement Presentational Component — PostsList
Note: You can click on the pictures to zoom and read

6.2 Implement Presentational Component — PostDetails

6.3 Implement Presentational Component — PostForm

Note: In the actual code, I am using the awesome redux-form library for form-validation. I’ll blog about it in a different post.
6.4 Implement Presentational Component — Header

Note: You can click on the pictures to zoom and read
STEP 7 — Create Container Component For Some/All Presentational Component
We have 4 components: PostList, PostDetails, PostForm and Header. Let’s create container components for each one.
7.1 Create Container Component — PostsListContainer

7.2 Create Container Component — PostDetailsContainer

7.3 Create Container Component — PostFormContainer

7.4 Create Container Component — HeaderContainer

STEP 8 — Finally Bring Them All Together
Below code is a simplified version of wiring everything together. Please see source code of the main index.js and reducers.js to get started.
import React from 'react'; <-- Main React lib
import ReactDOM from 'react-dom'; <-- Main React DOM lib
import { Provider } from 'react-redux';<-- Injects Redux to comps
import { createStore, applyMiddleware } from 'redux';<- Redux
import { Router, browserHistory } from 'react-router';<- Navigation
import reducers from './reducers'; <- Import reducers
import promise from 'redux-promise';
//Configure middleware w/ redux-promise for AJAX requests
const createStoreWithMiddleware = applyMiddleware(
  promise
)(createStore);
const store = createStoreWithMiddleware(reducers);
ReactDOM.render(
  <Provider store={store}> <- Inject global redux state to comps
    <Router history={browserHistory}>
       <Route path=”/” component={App}> <- Wrapper for all pages
         <IndexRoute component={PostsIndex} /> <-wrapper Index page
         <Route path=”posts/new” component={PostsNew} /> <- New page
         <Route path=”posts/:id” component={PostsShow} /> <-Details
       </Route>
    </Router>
</Provider>
  , document.getElementById('body'));
That’s it for now!


## Different Async Approaches


https://medium.com/react-native-training/redux-4-ways-95a130da0cdc


---

https://github.com/markerikson/react-redux-links/blob/master/redux-side-effects.md

Redux Side Effects

Basic Concepts and Thunks

Stack Overflow: Dispatching Redux Actions with a Timeout
http://stackoverflow.com/questions/35411423/how-to-dispatch-a-redux-action-with-a-timeout/35415559#35415559
Dan Abramov explains the basics of managing async behavior in Redux, walking through a progressive series of approaches (inline async calls, async action creators, thunk middleware).

Stack Overflow: Why do we need middleware for async flow in Redux?
http://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux/34599594#34599594
Dan Abramov gives reasons for using thunks and async middleware, and some useful patterns for using thunks.

Pure Functionality and Side Effects with Redux
https://blog.hivejs.org/building-the-ui-2/
An overview of what side effects are, how they fit into Redux, and several approaches for managing them.

"Async Redux workflow: calling actions outside Redux?"
https://www.reddit.com/r/reactjs/comments/4upe9t/async_redux_workflow_calling_actions_outside_redux/d5sgy5s?context=3
A comment explaining why using action creator functions is a good practice

Why doesn't Redux support AJAX out of the box?
http://goshakkk.name/redux-no-ajax-by-default/
Looks at how AJAX calls fit into a Redux application

Adding Customized Asynchrony to Redux
https://anyperk.engineering/im-lauren-and-i-m-a-frontend-apprentice-here-at-anyperk-a1a40106d231
A quick introduction to some of the libraries that can be used to manage asynchronous behavior in Redux.

A Dummy's Guide to Redux and Thunk in React
https://medium.com/@stowball/a-dummys-guide-to-redux-and-thunk-in-react-d8904a7005d3
A tutorial that shows how to take a React component that does its own data fetching, and rework it to use accept data from Redux and use a thunk action creator instead.

What the heck is a "thunk"?
https://daveceddia.com/what-is-a-thunk/
A quick explanation for what the word "thunk" means in general, and for Redux specifically..

Understanding how redux-thunk works
https://medium.com/@gethylgeorge/understanding-how-redux-thunk-works-72de3bdebc50
An attempt to explain both redux-thunk and Redux's applyMiddleware enhancer, by rewriting the original implementations to add logging and rework names for ease of understanding.

Async Actions with Redux Thunk Demystified
http://blog.jakoblind.no/2017/04/25/async-actions-with-redux-thunk-demystified/
A quick look at the source code for redux-thunk, how it works, and how to use it.

Side Effect Approach Comparisons

Redux side effects and you
https://medium.com/javascript-and-opinions/redux-side-effects-and-you-66f2e0842fc3
Thoughts on the proliferation of new side effect libs for Redux, and some comparisons of the commonly used approaches.

"Controversial opinion: redux-thunk is too powerful"
https://twitter.com/intelligibabble/status/800103510624727040
https://twitter.com/dan_abramov/status/800310164792414208
Some discussion on the pros and cons of redux-thunk's flexibility and usage, as well as possible issues with multiple dispatches in a row.

Idiomatic Redux: Thoughts on Thunks, Sagas, Abstractions, and Reusability
http://blog.isquaredsoftware.com/2017/01/idiomatic-redux-thoughts-on-thunks-sagas-abstraction-and-reusability/
A response to several "thunks are bad" concerns, arguing that thunks (and sagas) are still a valid approach for managing complex sync logic and async side effects.

What are the benefits, pros, and cons of redux-thunk over redux-saga? https://hashnode.com/post/what-are-the-benefits-of-redux-thunk-over-redux-saga-what-pros-and-cons-do-they-have-over-each-other-ciqvyydh7065w3g53ffalif61
An excellent discussion of where side effects belong in a Redux app, and how thunks and sagas can be used to handle async logic.

Keeping Redux in check
https://medium.com/@georgeleeme/keeping-redux-in-check-78534504b215
Some tips on use of the Flux Standard Actions convention, and comparison of using redux-thunk vs redux-promise.

"Argument: We should switch from thunks to sagas"
http://en.arguman.org/we-should-switch-from-redux-thunk-to-redux-saga
An debate flowchart with arguments for and against using thunks and sagas

The Evolution of Redux Action Creators
https://medium.com/@northerneyes/the-evolution-of-redux-action-creators-2973018bf2ae
A comparison of ways to make action creation testable, looking at redux-thunk, a custom thunk-like middleware, and redux-saga

What is the right way to do asynchronous operations in Redux?
https://decembersoft.com/posts/what-is-the-right-way-to-do-asynchronous-operations-in-redux/
An excellent look at the most popular libraries for Redux side effects, with comparisons of how each one works.

Redux 4 Ways
https://medium.com/react-native-training/redux-4-ways-95a130da0cdc
Side-by-side comparisons of implementing some basic data fetching using thunks, sagas, observables, and a promise middleware

3 Common Approaches to Side-Effects in Redux
https://goshakkk.name/redux-side-effect-approaches/
An overview of what "side effects" are, how they relate to Redux, and the most common ways to handle side effects in a Redux app

Redux: Thunk vs Saga
http://blog.jakegardner.me/redux-thunk-vs-saga/
A couple quick examples showing how to use thunks and sagas for the same task

Sagas

Master Complex Redux Workflows with Sagas
http://konkle.us/master-complex-redux-workflows-with-sagas/
Describes what sagas are, how Redux-Saga uses generators to run sagas, some potential concerns, and how to use them.

Stack Overflow: Why do we need middleware for async flux in Redux?
http://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux/34623840#34623840
A comparison of imperative thunks vs declarative sagas, and some of the benefits that sagas can provide for testing and decoupling of logic.

Managing Side Effects in React + Redux using Sagas
http://jaysoo.ca/2016/01/03/managing-processes-in-redux-using-sagas/
Demonstrates various ways to implement a Timer app as a state machine, including using sagas to manage the periodic updates.

Persist Redux State By Using Sagas
http://engineering.invisionapp.com/post/persist-redux-state-by-using-sagas/
A very well-written set of examples showing how to use sagas to implement some complex store persistence logic.

Handling async in Redux with Sagas
http://wecodetheweb.com/2016/10/01/handling-async-in-redux-with-sagas/
Covers the basic concepts and syntax of sagas, and how they can improve testability. (Updated version of a 2015 post, covering the latest version of redux-saga.)

Redux Saga conceptual diagram
https://twitter.com/kuy/status/731484272234663937
A useful diagram illustrating the various things a saga can do

"Redux Sagas benefits?"
https://www.reddit.com/r/reactjs/comments/4ng8rr/redux_sagas_benefits/
Discussion of when and why you might want to use sagas, with some great examples in the comments.

Manage Side Effects Efficiently with Redux Saga
https://youtu.be/QJVdcIlqGwc
A presentation describing the concepts of generators and sagas.

Redux Saga conceptual diagram
https://qiita-image-store.s3.amazonaws.com/0/69860/8cc1a873-c675-9009-570d-9684da4a704f.png
A nifty diagram from @kuy illustrating the general interaction of Redux Saga's async flow operators

Async Operations using Redux-Saga
https://medium.com/@andresmijares25/async-operations-using-redux-saga-2ba02ae077b3
An example of using Redux-Saga to coordinate multiple async calls based on another article's flight data scenario.

Should I use redux-saga or not?
https://speakerdeck.com/kuy/should-i-use-redux-saga-or-not
A presentation from Yuki Kodama, comparing side effect approaches. In Japanese, but still has a number of useful diagrams that can be understood by English speakers.

Interview with Redux-Saga Author Yassine Eloaufi
http://survivejs.com/blog/redux-saga-interview/
An interview with the author of Redux-Saga, where he describes some of its concepts and history

Lazy registration with Redux and Sagas
http://goshakkk.name/lazy-auth-redux-saga-flow/
Examples of using Redux-Saga to implement an async series of user interactions.

A Saga that led Xero to Redux
https://devblog.xero.com/a-saga-that-led-xero-to-redux-aa1361b9a800
Examples of how Xero's async logic for their dashboard evolved over team, from nested callbacks to promises to Redux with sagas

The Three 'R's: Refactoring, React, and Redux for robust async JS
https://devblog.xero.com/the-three-rs-refactoring-react-and-redux-for-robust-async-js-252648a8632f
More information from Xero on how they have used sagas for async workflows, including splitting code up into smaller sagas that can be composed.

4 Quick Tips for Managing Many Sagas in a React-Redux-Saga App
https://decembersoft.com/posts/4-tips-for-managing-many-sagas-in-a-react-redux-saga-app/
Some useful suggestions for structuring and organizing sagas

Implementing feature flags using React and Redux Saga
http://blog.launchdarkly.com/implementing-feature-flags-in-single-page-apps-using-react-and-redux-saga/
A quick example of how to use sagas to manage feature flag API requests

Other Side Effect Approaches

Epic Middleware in Redux
https://medium.com/@kevinsalter/epic-middleware-in-redux-e4385b6ff7c6
Discussion and examples of using Redux-Observable and RxJS to create "epics" which can transform actions.

Better async Redux
https://blog.scottnonnenberg.com/better-async-redux-i18n-and-node-js-versions/
Comparisons and examples of using Redux-Loop for declarative side effects

Action Streams and Redux
https://medium.com/@markusctz/action-streams-and-redux-77f8ac99c2e9
Examples of how Redux-Observable can simplify complex async logic

A simplified approach to calling APIs with Redux
http://www.sohamkamani.com/blog/2016/06/05/redux-apis/
A well-written example of creating a "data service" middleware that handles API requests, as well as examples of handling some request status state.

Elm Architecture with Redux
https://smallbusinessforum.co/elm-architecture-with-react-redux-redux-loop-645a67070b1a
A short look at how Elm handles side effects, and how Redux-Loop can help implement a similar approach in Redux

----

http://blog.isquaredsoftware.com/series/practical-redux/

Practical Redux, Part 8: Form Draft Data Management
Posted on Jan 26, 2017
Generic entity reducer logic, form current/draft data management, and form reset handling

Read more »
Practical Redux, Part 7: Form Change Handling, Data Editing, and Feature Reducers
Posted on Jan 12, 2017
Techniques for managing form events, data editing capabilities, and reducer structures for features

Read more »
Practical Redux, Part 6: Connected Lists, Forms, and Performance
Posted on Jan 10, 2017
Connecting lists and forms, performance guidelines, editing features, and UI state

Read more »
Practical Redux, Part 5: Loading and Displaying Data
Posted on Dec 12, 2016
Sourcemaps, sample data, basic data management, and selection handling

Read more »
Practical Redux, Part 4: UI Layout and Project Structure
Posted on Nov 22, 2016
UI libraries, folder structures, tab panel management, and initial layout with mock contents

Read more »
Practical Redux, Part 3: Project Planning and Setup
Posted on Nov 10, 2016
Initial steps for our sample application

Read more »
Practical Redux, Part 2: Redux-ORM Concepts and Techniques
Posted on Oct 31, 2016
Useful techniques for using Redux-ORM to help manage your normalized state, part 2:
In-depth examples of how I use Redux-ORM

Read more »
Practical Redux, Part 1: Redux-ORM Basics
Posted on Oct 31, 2016
Useful techniques for using Redux-ORM to help manage your normalized state, part 1:
Redux-ORM use cases and basic usage

Read more »
Practical Redux, Part 0: Introduction
Posted on Oct 31, 2016
First in a series covering Redux techniques based on my own experience



---------

https://github.com/reactjs/react-redux/blob/master/docs/api.md

## Redux API

connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])

Connects a React component to a Redux store. connect is a facade around connectAdvanced, providing a convenient API for the most common use cases.

It does not modify the component class passed to it; instead, it returns a new, connected component class for you to use.

### Arguments

#### mapStateToProps

[mapStateToProps(state, [ownProps]): stateProps] (Function): If this argument is specified, the new component will subscribe to Redux store updates. This means that any time the store is updated, mapStateToProps will be called. The results of mapStateToProps must be a plain object*, which will be merged into the component’s props. If you don't want to subscribe to store updates, pass null or undefined in place of mapStateToProps. If ownProps is specified as a second argument, its value will be the props passed to your component, and mapStateToProps will be additionally re-invoked whenever the component receives new props (e.g. if props received from a parent component have shallowly changed, and you use the ownProps argument, mapStateToProps is re-evaluated).

Note: in advanced scenarios where you need more control over the rendering performance, mapStateToProps() can also return a function. In this case, that function will be used as mapStateToProps() for a particular component instance. This allows you to do per-instance memoization. You can refer to #279 and the tests it adds for more details. Most apps never need this.

The mapStateToProps function takes a single argument of the entire Redux store’s state and returns an object to be passed as props. It is often called a selector. Use reselect to efficiently compose selectors and compute derived data.

#### mapDispatchToProps

[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function): If an object is passed, each function inside it is assumed to be a Redux action creator. An object with the same function names, but with every action creator wrapped into a dispatch call so they may be invoked directly, will be merged into the component’s props. If a function is passed, it will be given dispatch. If you don't want to subscribe to store updates, pass null or undefined in place of mapStateToProps. It’s up to you to return an object that somehow uses dispatch to bind action creators in your own way. (Tip: you may use the bindActionCreators() helper from Redux.) If you omit it, the default implementation just injects dispatch into your component’s props. If ownProps is specified as a second argument, its value will be the props passed to your component, and mapDispatchToProps will be re-invoked whenever the component receives new props.

Note: in advanced scenarios where you need more control over the rendering performance, mapDispatchToProps() can also return a function. In this case, that function will be used as mapDispatchToProps() for a particular component instance. This allows you to do per-instance memoization. You can refer to #279 and the tests it adds for more details. Most apps never need this.

#### mergeProps

[mergeProps(stateProps, dispatchProps, ownProps): props] (Function): If specified, it is passed the result of mapStateToProps(), mapDispatchToProps(), and the parent props. The plain object you return from it will be passed as props to the wrapped component. You may specify this function to select a slice of the state based on props, or to bind action creators to a particular variable from props. If you omit it, Object.assign({}, ownProps, stateProps, dispatchProps) is used by default.

#### options

[options] (Object) If specified, further customizes the behavior of the connector. In addition to the options passable to connectAdvanced() (see those below), connect() accepts these additional options:

* [pure] (Boolean): If true, connect() will avoid re-renders and calls to mapStateToProps, mapDispatchToProps, and mergeProps if the relevant state/props objects remain equal based on their respective equality checks. Assumes that the wrapped component is a “pure” component and does not rely on any input or state other than its props and the selected Redux store’s state. Default value: true
* [areStatesEqual] (Function): When pure, compares incoming store state to its previous value. Default value: strictEqual (===)
* [areOwnPropsEqual] (Function): When pure, compares incoming props to its previous value. Default value: shallowEqual
* [areStatePropsEqual] (Function): When pure, compares the result of mapStateToProps to its previous value. Default value: shallowEqual
* [areMergedPropsEqual] (Function): When pure, compares the result of mergeProps to its previous value. Default value: shallowEqual

### The arity of mapStateToProps and mapDispatchToProps determines whether they receive ownProps

Note: ownProps is not passed to mapStateToProps and mapDispatchToProps if formal definition of the function contains one mandatory parameter (function has length 1). For example, function defined like below won't receive ownProps as the second argument.

```
function mapStateToProps(state) {
  console.log(state); // state
  console.log(arguments[1]); // undefined
}
```

```
const mapStateToProps = (state, ownProps = {}) => {
  console.log(state); // state
  console.log(ownProps); // undefined
}
```

Functions with no mandatory parameters or two parameters will receive ownProps.

```
const mapStateToProps = (state, ownProps) => {
  console.log(state); // state
  console.log(ownProps); // ownProps
}
```

```
function mapStateToProps() {
  console.log(arguments[0]); // state
  console.log(arguments[1]); // ownProps
}
```

```
const mapStateToProps = (...args) => {
  console.log(args[0]); // state
  console.log(args[1]); // ownProps
}
```

Optimizing connect when options.pure is true

When options.pure is true, connect performs several equality checks that are used to avoid unncessary calls to mapStateToProps, mapDispatchToProps, mergeProps, and ultimately to render. These include areStatesEqual, areOwnPropsEqual, areStatePropsEqual, and areMergedPropsEqual. While the defaults are probably appropriate 99% of the time, you may wish to override them with custom implementations for performance or other reasons. Here are several examples:

* You may wish to override areStatesEqual if your mapStateToProps function is computationally expensive and is also only concerned with a small slice of your state. For example: areStatesEqual: (prev, next) => prev.entities.todos === next.entities.todos; this would effectively ignore state changes for everything but that slice of state.
* You may wish to override areStatesEqual to always return false (areStatesEqual: () => false) if you have impure reducers that mutate your store state. (This would likely impact the other equality checks is well, depending on your mapStateToProps function.)
* You may wish to override areOwnPropsEqual as a way to whitelist incoming props. You'd also have to implement mapStateToProps, mapDispatchToProps and mergeProps to also whitelist props. (It may be simpler to achieve this other ways, for example by using recompose's mapProps.)
* You may wish to override areStatePropsEqual to use strictEqual if your mapStateToProps uses a memoized selector that will only return a new object if a relevant prop has changed. This would be a very slight performance improvement, since would avoid extra equality checks on individual props each time mapStateToProps is called.
* You may wish to override areMergedPropsEqual to implement a deepEqual if your selectors produce complex props. ex: nested objects, new arrays, etc. (The deep equal check should be faster than just re-rendering.)

### Returns

A higher-order React component class that passes state and action creators into your component derived from the supplied arguments. This is created by connectAdvanced, and details of this higher-order component are covered there.

### Examples

Inject just dispatch and don't listen to store

```
export default connect()(TodoApp)
```

Inject all action creators (addTodo, completeTodo, ...) without subscribing to the store

```
import * as actionCreators from './actionCreators'

export default connect(null, actionCreators)(TodoApp)
```

Inject dispatch and every field in the global state

Don’t do this! It kills any performance optimizations because TodoApp will rerender after every action.
It’s better to have more granular connect() on several components in your view hierarchy that each only
listen to a relevant slice of the state.

```
export default connect(state => state)(TodoApp)
```

Inject dispatch and todos

```
function mapStateToProps(state) {
  return { todos: state.todos }
}

export default connect(mapStateToProps)(TodoApp)
```

Inject todos and all action creators

```
import * as actionCreators from './actionCreators'

function mapStateToProps(state) {
  return { todos: state.todos }
}

export default connect(mapStateToProps, actionCreators)(TodoApp)
```

Inject todos and all action creators (addTodo, completeTodo, ...) as actions

```
import * as actionCreators from './actionCreators'
import { bindActionCreators } from 'redux'

function mapStateToProps(state) {
  return { todos: state.todos }
}

function mapDispatchToProps(dispatch) {
  return { actions: bindActionCreators(actionCreators, dispatch) }
}

export default connect(mapStateToProps, mapDispatchToProps)(TodoApp)
```

Inject todos and a specific action creator (addTodo)

```
import { addTodo } from './actionCreators'
import { bindActionCreators } from 'redux'

function mapStateToProps(state) {
  return { todos: state.todos }
}

function mapDispatchToProps(dispatch) {
  return bindActionCreators({ addTodo }, dispatch)
}

export default connect(mapStateToProps, mapDispatchToProps)(TodoApp)
```

Inject todos, todoActionCreators as todoActions, and counterActionCreators as counterActions

```
import * as todoActionCreators from './todoActionCreators'
import * as counterActionCreators from './counterActionCreators'
import { bindActionCreators } from 'redux'

function mapStateToProps(state) {
  return { todos: state.todos }
}

function mapDispatchToProps(dispatch) {
  return {
    todoActions: bindActionCreators(todoActionCreators, dispatch),
    counterActions: bindActionCreators(counterActionCreators, dispatch)
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(TodoApp)
```

Inject todos, and todoActionCreators and counterActionCreators together as actions

```
import * as todoActionCreators from './todoActionCreators'
import * as counterActionCreators from './counterActionCreators'
import { bindActionCreators } from 'redux'

function mapStateToProps(state) {
  return { todos: state.todos }
}

function mapDispatchToProps(dispatch) {
  return {
    actions: bindActionCreators(Object.assign({}, todoActionCreators, counterActionCreators), dispatch)
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(TodoApp)
```

Inject todos, and all todoActionCreators and counterActionCreators directly as props

```
import * as todoActionCreators from './todoActionCreators'
import * as counterActionCreators from './counterActionCreators'
import { bindActionCreators } from 'redux'

function mapStateToProps(state) {
  return { todos: state.todos }
}

function mapDispatchToProps(dispatch) {
  return bindActionCreators(Object.assign({}, todoActionCreators, counterActionCreators), dispatch)
}

export default connect(mapStateToProps, mapDispatchToProps)(TodoApp)
```

Inject todos of a specific user depending on props

```
import * as actionCreators from './actionCreators'

function mapStateToProps(state, ownProps) {
  return { todos: state.todos[ownProps.userId] }
}

export default connect(mapStateToProps)(TodoApp)
```

Inject todos of a specific user depending on props, and inject props.userId into the action

```
import * as actionCreators from './actionCreators'

function mapStateToProps(state) {
  return { todos: state.todos }
}

function mergeProps(stateProps, dispatchProps, ownProps) {
  return Object.assign({}, ownProps, {
    todos: stateProps.todos[ownProps.userId],
    addTodo: (text) => dispatchProps.addTodo(ownProps.userId, text)
  })
}

export default connect(mapStateToProps, actionCreators, mergeProps)(TodoApp)
```

### connectAdvanced(selectorFactory, [connectOptions])

Connects a React component to a Redux store. It is the base for connect() but is less opinionated about how to combine state, props, and dispatch into your final props. It makes no assumptions about defaults or memoization of results, leaving those responsibilities to the caller.

It does not modify the component class passed to it; instead, it returns a new, connected component class for you to use.

#### Arguments

selectorFactory(dispatch, factoryOptions): selector(state, ownProps): props (Function): Intializes a selector function (during each instance's constructor). That selector function is called any time the connector component needs to compute new props, as a result of a store state change or receiving new props. The result of selector is expected to be a plain object, which is passed as the props to the wrapped component. If a consecutive call to selector returns the same object (===) as its previous call, the component will not be re-rendered. It's the responsibility of selector to return that previous object when appropriate.

[connectOptions] (Object) If specified, further customizes the behavior of the connector.

* [getDisplayName] (Function): computes the connector component's displayName property relative to that of the wrapped component. Usually overridden by wrapper functions. Default value: name => 'ConnectAdvanced('+name+')'
* [methodName] (String): shown in error messages. Usually overridden by wrapper functions. Default value: 'connectAdvanced'
* [renderCountProp] (String): if defined, a property named this value will be added to the props passed to the wrapped component. Its value will be the number of times the component has been rendered, which can be useful for tracking down unnecessary re-renders. Default value: undefined
* [shouldHandleStateChanges] (Boolean): controls whether the connector component subscribes to redux store state changes. If set to false, it will only re-render on componentWillReceiveProps. Default value: true
* [storeKey] (String): the key of props/context to get the store. You probably only need this if you are in the inadvisable position of having multiple stores. Default value: 'store'
* [withRef] (Boolean): If true, stores a ref to the wrapped component instance and makes it available via getWrappedInstance() method. Default value: false
* Addionally, any extra options passed via connectOptions will be passed through to your selectorFactory in the factoryOptions argument.


#### Returns

A higher-order React component class that builds props from the store state and passes them to the wrapped component. A higher-order component is a function which accepts a component argument and returns a new component.

Static Properties

WrappedComponent (Component): The original component class passed to connectAdvanced(...)(Component).
Static Methods

All the original static methods of the component are hoisted.

Instance Methods

getWrappedInstance(): ReactComponent

Returns the wrapped component instance. Only available if you pass { withRef: true } as part of the options argument.

#### Remarks

Since connectAdvanced returns a higher-order component, it needs to be invoked two times. The first time with its arguments as described above, and a second time, with the component: connectAdvanced(selectorFactory)(MyComponent).

connectAdvanced does not modify the passed React component. It returns a new, connected component, that you should use instead.


#### Examples

Inject todos of a specific user depending on props, and inject props.userId into the action

```
import * as actionCreators from './actionCreators'
import { bindActionCreators } from 'redux'

function selectorFactory(dispatch) {
  let ownProps = {}
  let result = {}
  const actions = bindActionCreators(actionCreators, dispatch)
  const addTodo = (text) => actions.addTodo(ownProps.userId, text)
  return (nextState, nextOwnProps) => {
    const todos = nextState.todos[nextProps.userId]
    const nextResult = { ...nextOwnProps, todos, addTodo }
    ownProps = nextOwnProps
    if (!shallowEqual(result, nextResult)) result = nextResult
    return result
  }
}
export default connectAdvanced(selectorFactory)(TodoApp)
```

----

https://medium.com/@adamrackis/querying-a-redux-store-37db8c7f3b0f

Any component wrapped with connect() call will receive a dispatch function as a prop, and any state it needs from the global state. In most cases you will only pass the first argument to connect(), which is a function we call a selector. This function takes the global Redux store’s state, and returns the props you need for the component. In the simplest case, you can just return the state given to you (i.e. pass identity function), but you may also wish to transform it first.

To make performant memoized transformations with composable selectors, check out reselect. In this example, we won’t use it, but it works great for larger apps.



### Connect -  Redux’s Container

There needs to be glue that connects the Redux data flow with the React components. The container is meant to be the file that holds all the data and functions required to connect store state and action creators actions to React component props. It is in this file where your action creators are imported, the Redux ‘connect’ function is imported, the parent React component is imported, and any other methods/data are imported (i.e routing and initial server loading).

```
import {connect} from 'react-redux';
import Template from '../components/Template.js'
import {increment, decrement} from '../actions/sidebar.js';
import {isBrowser} from '../env.js';
```

Now the connect function. The documentation for connect within Redux is difficult to understand, which creates a sense of mystery. Simply think of this as a component that takes props as parameters, which in return supplies actions and state to the provided React component via props… Confused yet? Well let’s break this down some more.

connect() is a function provided by react-redux. If a component wants to get state updates, it wraps itself using connect(). Then the connect function will set up all the wiring for it to the redux store.

The following shows the connect function breakdown:

```
connect(mapStateToProps, mapDispatchToProps, mergeProps, options)(component);
```

Connect returns a function that accepts a react component. It has 4 arguments.

* mapStateToProps - function, mandatory
* mapDispatchToProps - function or object, mandotory
* mergeProps — function, optional
* options — object, optional

When applied to a component, it returns a component connected to the store that renders the specified component.


## mapStateToProps

The function `mapStateToProps` connects state from the store to corresponding props. This make it possible to access your reducer state objects from within your React components.
As connect subscribes to the store automatically, a new render of the connected component triggered anytime a change of state triggers a change of value for any of the properties passed to the component.

`mapStateToProps` returns an object, where keys are the prop names passed to the connected component and the value a reducer function.

```
const mapStateToProps = ({ reducer1, reducer2}) => ({reducer1, reducer2 });
```

## mapDispatchToProps

`mapDispatchToProps` can ether be a function or an object.

As the only way to change the application state is by dispatching an action, this allows to create named function for handling dispatch calls (i.e.: action creator).

When the name funtion is called with arguments, the associated named function will be called with the current getState() result and the given action synchronously. Its return value will be considered the next state.

```
import {actionCreator1, actionCreator2} from '../actions/main.js';

const bindActionsToDispatch = (dispatch) => ({
    actionCreator1 : () => {dispatch(actionCreator1())},
    actionCreator2 : (e) => {dispatch(actionCreator2(e))}
});
```

### bindActionCreators

`mapDispatchToProps` is not the only way of bind dispatch and action creators, there is another way called `bindActionCreators`.

```
import { bindActionCreators } from 'redux';
import * as TodoActionCreators from './TodoActionCreators';

let boundActionCreators = bindActionCreators(TodoActionCreators, dispatch)
```

The only use case for bindActionCreators is when you want to pass some action creators down to a component that isn't aware of Redux, and you don't want to pass dispatch or the Redux store to it.

## mergeProps

`mergeProps` is an optional parameter and is a function. The documentation on this particular function does not explain much as to it’s purpose and use cases. Hence adding to the mystery of the connect function.

If it is used, this function is passed the result of `mapStateToProps`(), `mapDispatchToProps`(), and the parent props. With this data available, it is easy to use props inherited from connect’s parent and combine them with an action creator. For example, if you are working with React Router, the variables assigned in the route path are passed as props to the connect function, if it is the connect function’s parent. You could then use those props and pass it along to your action creators to update your store with the needed URL parameters.

```
const mergeProps = (state, actions, {notebook, note}) => ({
    ...state,
    ...actions,
    onLoad: notebook && note
      ? () => {
        return Promise.all([
          actions.initActiveNotebookAndNote({notebook, note})
        ])
      }
      : actions.onLoad
})
```

The above code is receiving state from mapStateToProps, actions from mapDispatchToProps, and is creating a new prop called ‘onLoad’. This prop ‘onLoad’ is combining or ‘merging’ (as it’s name states) props from it’s parent component (React Router) and an action creator together. That action creator can be used to update data within a Reducer:

```
export const initActiveNotebookAndNote = ({notebook, note}) => ({
 type: SET_CURRENT_NOTE,
 notebook,
 note
});
```

## options

The options parameter is an object. It is used to customize the behavior of the connect function. The acceptable ‘options’ are the following:

* pure- Boolean, if true connect() will avoid re-rendering (will not update)
* areStatesEqual- Compares new store state vs. old*
* areOwnPropsEqual- Compares new props vs. old*
* areStatePropsEqual- Compares new mapStateToProps vs. old*
* areMergedPropsEqual- Compares new mergeProps vs. old*

(*Only when pure functions)

These options are not commonly used and are best explained by Redux:

You may wish to override `areStatesEqual` if your `mapStateToProps` function is computationally expensive and is also only concerned with a small slice of your state. For example: areStatesEqual: (prev, next) => prev.entities.todos === next.entities.todos; this would effectively ignore state changes for everything but that slice of state.

You may wish to override `areStatesEqual` to always return false (areStatesEqual: () => false) if you have impure reducers that mutate your store state. (This would likely impact the other equality checks is well, depending on your mapStateToProps function.)

You may wish to override `areOwnPropsEqual` as a way to whitelist incoming props. You'd also have to implement mapStateToProps, mapDispatchToProps and mergeProps to also whitelist props. (It may be simpler to achieve this other ways, for example by using recompose's mapProps.)

You may wish to override `areStatePropsEqual` to use strictEqual if your mapStateToProps uses a memoized selector that will only return a new object if a relevant prop has changed. This would be a very slight performance improvement, since would avoid extra equality checks on individual props each time mapStateToProps is called.

You may wish to override `areMergedPropsEqual` to implement a deepEqual if your selectors produce complex props. ex: nested objects, new arrays, etc. (The deep equal check should be faster than just re-rendering.)


--------


Here is a final example that shows the connect function :

```
import {connect} from 'react-redux';
import Template from '../components/Template.js';
import {actionCreator1, actionCreator2} from '../actions/main.js';

const mapStateToProps = ({ reducer1, reducer2}) => ({reducer1, reducer2 });

const bindActionsToDispatch = dispatch => ({
    actionCreator1 : () => {dispatch(actionCreator1())},
    actionCreator2 : (e) => {dispatch(actionCreator2(e))}
});

const mergeProps = (state, actions, {notebook, note}) => ({
    ...state,
    ...actions,
    onLoad: notebook && note
      ? () => {
        return (
          actions.initActiveNotebookAndNote({notebook, note})
        )
      }
      : null
});

connect(mapStateToProps, mapDispatchToProps, mergeProps, { withRef: true })(Template);
```
